"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[876],{8141(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"vulnerabilities/zero-copy-alignment","title":"06 - Unaligned Pointer (Zero-Copy)","description":"Analysis","source":"@site/docs/vulnerabilities/06-zero-copy-alignment.md","sourceDirName":"vulnerabilities","slug":"/vulnerabilities/zero-copy-alignment","permalink":"/bytesUnchecked/docs/vulnerabilities/zero-copy-alignment","draft":false,"unlisted":false,"editUrl":"https://github.com/nathfavour/bytesUnchecked/tree/main/docs/docs/vulnerabilities/06-zero-copy-alignment.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"05 - Type Confusion","permalink":"/bytesUnchecked/docs/vulnerabilities/type-confusion"},"next":{"title":"07 - Hook Reentrancy","permalink":"/bytesUnchecked/docs/vulnerabilities/hook-reentrancy"}}');var i=t(4848),r=t(8453);const s={},o="06 - Unaligned Pointer (Zero-Copy)",c={},l=[{value:"Analysis",id:"analysis",level:2},{value:"Exploit (Insecure)",id:"exploit-insecure",level:2},{value:"Fix (Secure)",id:"fix-secure",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"06---unaligned-pointer-zero-copy",children:"06 - Unaligned Pointer (Zero-Copy)"})}),"\n",(0,i.jsx)(n.h2,{id:"analysis",children:"Analysis"}),"\n",(0,i.jsx)(n.p,{children:"Zero-copy accounts allow programs to interact with account data directly in the Solana memory space without deserializing it into a new struct. This is highly efficient for large accounts."}),"\n",(0,i.jsxs)(n.p,{children:["However, zero-copy requires that the account data is ",(0,i.jsx)(n.strong,{children:"aligned"})," correctly in memory (usually to 8 bytes). Accessing unaligned data through a raw pointer in Rust can lead to program panics or undefined behavior."]}),"\n",(0,i.jsx)(n.h2,{id:"exploit-insecure",children:"Exploit (Insecure)"}),"\n",(0,i.jsx)(n.p,{children:"Manually casting a data pointer without verifying alignment or using safe wrappers:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'pub fn update_insecure(ctx: Context<UpdateInsecure>, _val: u64) -> Result<()> {\n    let account_info = &ctx.accounts.data;\n    let data = account_info.try_borrow_data()?;\n    \n    //  Unsafe cast. If data is not 8-byte aligned, this is UB.\n    let ptr = data.as_ptr() as *const BigData;\n    unsafe { msg!("Value: {}", (*ptr).val); }\n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"fix-secure",children:"Fix (Secure)"}),"\n",(0,i.jsxs)(n.p,{children:["Use Anchor's ",(0,i.jsx)(n.code,{children:"AccountLoader"})," and the ",(0,i.jsx)(n.code,{children:"#[account(zero_copy)]"})," attribute. This ensures that the data is accessed through safe, alignment-aware wrappers."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[account(zero_copy)]\n#[repr(C)]\npub struct BigData {\n    pub val: u64,\n}\n\npub struct UpdateSecure<'info> {\n    #[account(mut)]\n    pub data: AccountLoader<'info, BigData>, //  Safe alignment handling\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453(e,n,t){t.d(n,{R:()=>s,x:()=>o});var a=t(6540);const i={},r=a.createContext(i);function s(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);