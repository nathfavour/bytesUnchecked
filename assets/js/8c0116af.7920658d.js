"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[33],{5178(e,t,n){n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"vulnerabilities/account-closing","title":"04 - Zombie Resurrection (Account Closing)","description":"Analysis","source":"@site/docs/vulnerabilities/04-account-closing.md","sourceDirName":"vulnerabilities","slug":"/vulnerabilities/account-closing","permalink":"/bytesUnchecked/docs/vulnerabilities/account-closing","draft":false,"unlisted":false,"editUrl":"https://github.com/nathfavour/bytesUnchecked/tree/main/docs/docs/vulnerabilities/04-account-closing.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"03 - PDA Metadata Leak","permalink":"/bytesUnchecked/docs/vulnerabilities/pda-seed-leak"},"next":{"title":"05 - Type Confusion","permalink":"/bytesUnchecked/docs/vulnerabilities/type-confusion"}}');var i=n(4848),o=n(8453);const r={},c="04 - Zombie Resurrection (Account Closing)",a={},l=[{value:"Analysis",id:"analysis",level:2},{value:"Exploit (Insecure)",id:"exploit-insecure",level:2},{value:"Fix (Secure)",id:"fix-secure",level:2}];function u(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"04---zombie-resurrection-account-closing",children:"04 - Zombie Resurrection (Account Closing)"})}),"\n",(0,i.jsx)(t.h2,{id:"analysis",children:"Analysis"}),"\n",(0,i.jsxs)(t.p,{children:['When a Solana account is "closed," its lamports are transferred to a destination account. However, if the program logic doesn\'t explicitly ',(0,i.jsx)(t.strong,{children:"zero out the data"}),", the bytes remain in the account's memory space until the runtime purges it."]}),"\n",(0,i.jsx)(t.p,{children:'If an attacker manages to re-fund the account with lamports before the data is purged, the program might interpret the "zombie" data as valid state, leading to logic errors.'}),"\n",(0,i.jsx)(t.h2,{id:"exploit-insecure",children:"Exploit (Insecure)"}),"\n",(0,i.jsx)(t.p,{children:"Manually transferring lamports without cleaning the memory:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"pub fn close_insecure(ctx: Context<CloseInsecure>) -> Result<()> {\n    let dest = ctx.accounts.destination.to_account_info();\n    let vault = ctx.accounts.vault.to_account_info();\n\n    let dest_lamports = dest.lamports();\n    **dest.lamports.borrow_mut() = dest_lamports + vault.lamports();\n    **vault.lamports.borrow_mut() = 0; // Data still exists in memory!\n    Ok(())\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"fix-secure",children:"Fix (Secure)"}),"\n",(0,i.jsx)(t.p,{children:"Properly closing an account requires two steps:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Transferring all lamports."}),"\n",(0,i.jsx)(t.li,{children:"Overwriting the data with zeros."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Anchor's ",(0,i.jsx)(t.code,{children:"close = destination"})," constraint handles this automatically and securely."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"pub fn close_secure(ctx: Context<CloseSecure>) -> Result<()> {\n    // Anchor automatically zeros data and transfers lamports\n    Ok(())\n}\n"})})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453(e,t,n){n.d(t,{R:()=>r,x:()=>c});var s=n(6540);const i={},o=s.createContext(i);function r(e){const t=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);